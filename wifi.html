<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <title>ChromeOS WiFi Password Extractor | hapara.fail</title>
  <link rel="icon" type="image/png" href="favicon.png">
  <style>
    /* Base Styles - Consistent with other pages */
    html,
    body {
      margin: 0;
      padding: 0;
      height: 100%;
      background-color: #000;
      color: #fff;
      font-family: 'Monaco', 'Consolas', 'Lucida Console', monospace;
      overflow-x: hidden;
      position: relative;
    }

    body {
      min-height: 100%;
    }

    body.overlay-active {
      overflow-y: hidden;
    }

    /* TSparticles Container Style - Consistent */
    #tsparticles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    /* Content Styling - Consistent */
    .content-wrapper {
      position: relative;
      z-index: 1;
      padding: 20px;
      padding-top: 80px;
      padding-bottom: 40px;
      max-width: 900px;
      margin-left: auto;
      margin-right: auto;
      box-sizing: border-box;
      line-height: 1.7;
      color: #e0e0e0;
      min-height: calc(100vh - 120px);
    }

    .content-wrapper h1,
    .content-wrapper h2,
    .content-wrapper h3,
    .content-wrapper h4 { /* Added h4 for consistency */
      color: #fff;
      margin-top: 2.5rem;
      margin-bottom: 1.2rem;
      font-weight: bold;
    }

    .content-wrapper h1 {
      font-size: clamp(1.8rem, 3.8vw, 2.6rem);
      margin-top: 0;
    }

    .content-wrapper h2 {
      font-size: clamp(1.5rem, 3.2vw, 2.1rem);
      border-top: 1px solid #333; 
      padding-top: 2rem;
      margin-top: 3rem;
    }
    .content-wrapper h2.first-tool-heading { /* Special class for the first H2 tool heading */
        border-top: none;
        padding-top: 0;
        margin-top: 2.5rem; 
    }


    .content-wrapper h3 {
      font-size: clamp(1.2rem, 2.8vw, 1.8rem);
    }
    .content-wrapper h4 { /* Style for H4 used in new structure */
        font-size: clamp(1.1rem, 2.5vw, 1.6rem); 
        color: #e0e0e0; 
        margin-top:2rem; 
        margin-bottom: 1rem;
    }


    .content-wrapper p,
    .content-wrapper li {
      margin-bottom: 1rem;
      color: #ccc;
    }

    .content-wrapper ul,
    .content-wrapper ol {
      margin-bottom: 1.5rem;
      padding-left: 30px;
    }

    .content-wrapper .meta-info {
      font-size: 0.9rem;
      color: #aaa;
      margin-bottom: 1.5rem; /* Adjusted margin */
      margin-top: 0.5rem;
    }

    .content-wrapper code {
      background-color: #2a2a2a;
      padding: 3px 7px;
      border-radius: 4px;
      font-size: 0.9em;
      color: #61dafb;
      border: 1px solid #444;
    }

    .content-wrapper pre {
      background-color: #1e1e1e;
      padding: 15px;
      border-radius: 6px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-break: break-word;
      color: #d4d4d4;
      border: 1px solid #333;
      font-size: 0.9em;
      line-height: 1.6;
      margin-bottom: 1.5rem;
    }

    .content-wrapper strong {
      color: #fff;
    }

    .content-wrapper a {
      color: #61dafb;
      text-decoration: underline;
    }

    .content-wrapper a:hover {
      color: #82e9ff;
    }
    .content-wrapper .warning { color: #ffcc00; } 
    .content-wrapper .critical-warning { color: #ff6b6b; } 

    .content-wrapper .note {
      background-color: rgba(40, 40, 45, 0.7);
      border-left: 4px solid #61dafb;
      padding: 10px 15px;
      margin: 1.5rem 0;
      border-radius: 0 4px 4px 0;
      font-size: 0.95rem;
    }

    .content-wrapper .note strong {
      color: #61dafb;
    }

    .content-wrapper .credits {
      font-size: 0.9rem;
      color: #aaa;
      margin-top: 3rem;
      margin-bottom: 1rem;
      text-align: left;
    }
    
    .quick-guide ul {
        list-style-type: disc; /* Or 'circle' or 'square' */
        padding-left: 25px; /* Indent list */
    }
    .quick-guide li {
        margin-bottom: 0.5rem; /* Space between list items */
    }


    /* Tool Styles (Generic for both tools) */
    .extractor-tool-section {
      background-color: rgba(20, 20, 22, 0.85);
      backdrop-filter: blur(8px);
      padding: 20px 25px;
      border-radius: 8px;
      margin-top: 1rem; /* Space after H4 */
      margin-bottom: 2.5rem;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }
    
    /* Specific styling for tool step headings if needed, or just use H4 */
    .tool-step-heading { /* Example if we need distinct styling for "Step A/B/C" */
        font-size: 1.1rem;
        color: #61dafb; /* Accent color for step headings */
        margin-top: 1.8rem;
        margin-bottom: 0.8rem;
        /* border-bottom: 1px dashed #444; */
        /* padding-bottom: 0.5rem; */
    }


    .extractor-tool-section label {
      display: block;
      margin-bottom: 8px;
      color: #ccc;
      font-size: 0.9rem;
    }

    .extractor-tool-section input[type="text"],
    .extractor-tool-section textarea,
    .extractor-tool-section input[type="file"] {
      width: 100%;
      background-color: #18181a;
      color: #e8e8e8;
      border: 1px solid #383838;
      border-radius: 6px;
      padding: 10px 12px;
      font-family: 'Monaco', 'Consolas', 'Lucida Console', monospace;
      font-size: 0.9rem;
      box-sizing: border-box;
      margin-bottom: 10px;
    }
    .extractor-tool-section input[type="file"] {
        padding: 8px 10px; 
        color: #ccc; 
    }
    .extractor-tool-section input[type="file"]::file-selector-button {
        background-color: #333;
        color: #fff;
        border: none;
        padding: 6px 10px;
        border-radius: 4px;
        cursor: pointer;
        margin-right: 10px;
    }


    .extractor-tool-section textarea {
      min-height: 100px;
      max-height: 200px;
      resize: vertical;
    }

    .extractor-tool-section button {
      background-color: #61dafb;
      color: #000;
      border: none;
      padding: 10px 22px;
      font-family: inherit;
      font-size: 0.95rem;
      font-weight: bold;
      border-radius: 50px;
      cursor: pointer;
      transition: background-color 0.2s ease-in-out, transform 0.1s ease;
      display: inline-block;
      margin-top: 5px;
      margin-bottom: 10px; /* Added margin for spacing */
    }

    .extractor-tool-section button:hover {
      background-color: #82e9ff;
      transform: translateY(-1px);
    }
    .extractor-tool-section button:active {
      transform: translateY(0px);
    }

    .tool-output-container { 
      margin-top: 15px;
    }
    .tool-output-container h4 { /* Output heading matches other H4s */
        margin-top: 0; /* Reset top margin as it's inside container */
        margin-bottom: 10px;
    }
    .tool-output-container pre {
      margin-top: 0;
      max-height: 300px;
      overflow-y: auto;
      font-size: 0.85rem;
    }
    .tool-output-container .error { color: #ff6b6b; }
    .tool-output-container .success { color: #50fa7b; }

    #nppe_output_table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
        font-size: 0.85rem;
    }
    #nppe_output_table th,
    #nppe_output_table td {
        border: 1px solid #333;
        padding: 8px 10px;
        text-align: left;
        color: #ccc;
    }
    #nppe_output_table th {
        background-color: #2a2a2a;
        color: #fff;
        font-weight: bold;
    }
    #nppe_output_table tr:nth-child(even) {
        background-color: #131313;
    }

    /* --- UPDATED Navigation Systems CSS --- */
    .menu-trigger {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1005; 
      background: none;
      border: none;
      padding: 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 0;
    }
    .menu-trigger svg {
      width: 24px;
      height: 24px; 
      color: #FFFFFF;
      transition: color 0.2s ease-in-out;
    }
    .menu-trigger:hover svg {
      color: #AAAAAA;
    }
    .menu-trigger .line {
      transform-origin: 12px 12px;
      transition: transform 0.25s cubic-bezier(0.55, 0.055, 0.675, 0.19), 
                  opacity 0.15s 0.1s linear; 
    }
    .line1 { transform: translateY(-6px); }
    .line3 { transform: translateY(6px); }
    .menu-trigger.is-active .line1 { transform: rotate(45deg); }
    .menu-trigger.is-active .line2 { opacity: 0; transition: opacity 0.1s linear; }
    .menu-trigger.is-active .line3 { transform: rotate(-45deg); }

    .fullscreen-menu { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: #0A0A0A; z-index: 1000; display: none; flex-direction: column; align-items: flex-start; justify-content: flex-end; opacity: 0; transition: opacity 0.3s ease-in-out; padding: 8vh 6vw; box-sizing: border-box; overflow-y: auto; }
    .fullscreen-menu.is-active { display: flex; opacity: 1; }
    .fullscreen-menu-list { list-style: none; padding: 0; margin: 0; text-align: left; }
    .fullscreen-menu-list li { margin: 12px 0; }
    .fullscreen-menu-list a { color: #ccc; text-decoration: none; font-size: clamp(1.1rem, 2.5vw, 1.5rem); font-weight: 500; padding: 8px 0; transition: color 0.2s ease-in-out, letter-spacing 0.2s ease-in-out; display: block; }
    .fullscreen-menu-list a:hover, .fullscreen-menu-list a:focus { color: #fff; letter-spacing: 0.5px; outline: none; }
    .fullscreen-menu .command-palette-tip { font-size: 0.8rem; color: #555; margin-top: 30px; width: 100%; text-align: left; }
    
    .command-palette-backdrop { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.3); backdrop-filter: blur(4px); z-index: 1008; display: none; opacity: 0; transition: opacity 0.2s ease-in-out; }
    .command-palette-backdrop.is-active { display: block; opacity: 1; }
    
    .command-palette { position: fixed; top: 20%; left: 50%; transform: translateX(-50%); width: 90%; max-width: 560px; background-color: #1C1C1E; border-radius: 12px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 0 1px rgba(255, 255, 255, 0.08); z-index: 1010; display: none; flex-direction: column; overflow: hidden; opacity: 0; transform: translateX(-50%) scale(0.95); transition: opacity 0.15s ease-in-out, transform 0.15s ease-in-out; }
    .command-palette.is-active { display: flex; opacity: 1; transform: translateX(-50%) scale(1); }
    .command-palette-input-wrapper { display: flex; align-items: center; padding: 0 15px; border-bottom: 1px solid rgba(255, 255, 255, 0.1); }
    .command-palette-input-wrapper svg { width: 20px; height: 20px; fill: #888; margin-right: 10px; flex-shrink: 0; }
    .command-palette-input { width: 100%; padding: 15px 0; font-family: inherit; font-size: 1.2rem; color: #f0f0f0; background-color: transparent; border: none; outline: none; }
    .command-palette-input::placeholder { color: #666; }
    .command-palette-results { list-style: none; padding: 0; margin: 0; max-height: 300px; overflow-y: auto; padding: 8px 0; }
    .command-palette-results li { padding: 10px 20px; cursor: pointer; color: #ccc; font-size: 0.95rem; border-bottom: 1px solid rgba(255, 255, 255, 0.05); transition: background-color 0.1s ease-in-out; display: flex; align-items: center; }
    .command-palette-results li:last-child { border-bottom: none; }
    .command-palette-results li:hover, .command-palette-results li.is-selected { background-color: #007AFF; color: #fff; }
    .command-palette-results li .item-name { flex-grow: 1; }
    .command-palette-results li .item-type { font-size: 0.8rem; color: #888; margin-left: 10px; flex-shrink: 0; }
    .command-palette-results li:hover .item-type, .command-palette-results li.is-selected .item-type { color: #eee; }
    .command-palette-no-results { padding: 20px; text-align: center; color: #888; font-size: 0.95rem; display: none; }
    .visually-hidden { position: absolute; width: 1px; height: 1px; margin: -1px; padding: 0; overflow: hidden; clip: rect(0, 0, 0, 0); border: 0; }

    @media (prefers-reduced-motion: reduce) { 
        #tsparticles { display: none !important; } 
        .extractor-tool-section { backdrop-filter: none; } 
        .fullscreen-menu, .command-palette, .command-palette-backdrop, .menu-trigger .line { transition: none !important; } 
    }
  </style>
</head>

<body>

  <button class="menu-trigger" aria-label="Open navigation menu" aria-expanded="false">
    <svg class="menu-icon-lines" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path class="line line1" d="M4 12H20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      <path class="line line2" d="M4 12H20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
      <path class="line line3" d="M4 12H20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
    </svg>
  </button>

  <div class="fullscreen-menu" role="dialog" aria-modal="true" aria-labelledby="menuTitleWifi">
    <h2 id="menuTitleWifi" class="visually-hidden">Site Navigation</h2>
    <nav>
      <ul class="fullscreen-menu-list"></ul>
    </nav>
    <p class="command-palette-tip">Tip: Press Ctrl+K or Cmd+K for quick search</p>
  </div>

  <div class="command-palette-backdrop"></div>
  <div class="command-palette" role="dialog" aria-modal="true" aria-labelledby="commandPaletteLabelWifi">
    <div class="command-palette-input-wrapper">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z" /></svg>
      <input type="search" class="command-palette-input" placeholder="Type a command or search..." id="commandPaletteLabelWifi" autocomplete="off">
    </div>
    <ul class="command-palette-results"></ul>
    <div class="command-palette-no-results">No results found.</div>
  </div>
  <span class="visually-hidden" id="commandPaletteHintWifi">Command Palette: Type to search site pages and links. Use arrow keys to navigate, Enter to select, Escape to close.</span>

  <div id="tsparticles" aria-hidden="true"></div>

  <div class="content-wrapper">
    <h1>ChromeOS WiFi Password Extractor</h1>
    <p class="meta-info"><strong>Last updated:</strong> May 22, 2025</p>

    <p>This page provides two tools to help find saved WiFi passwords or configuration details on ChromeOS. Each tool approaches the problem differently and is suited for different scenarios.</p>

    <div class="quick-guide">
        <h3>Quick Guide: Which Tool to Use?</h3>
        <p>Not sure where to start? Hereâ€™s a quick tip:</p>
        <ul>
            <li><strong>Use Tool 1 (Sync Internals Extractor) if:</strong> You're trying to find the password for a WiFi network that uses a simple shared passphrase (like those common in homes, often using WPA2-Personal/PSK authentication) AND you believe ChromeOS might have synced this password with your Google account.</li>
            <li><strong>Use Tool 2 (Network Policy Extractor - NPPE) if:</strong> You suspect the WiFi network details were configured by an administrator via policy (common in schools or businesses), the network uses more complex enterprise authentication (like WPA-EAP), or Tool 1 didn't provide any results. This tool looks for configurations that might be "pushed" to the device as part of its management policies.</li>
        </ul>
    </div>

    <div class="note">
        <p><strong>Important General Note:</strong> The success of these methods heavily depends on your ChromeOS version, how your device is managed by any administrative policies, and the specific type of WiFi network. For many enterprise networks (e.g., those requiring individual user credentials via WPA-EAP with certificates), these tools will likely not reveal a simple user-enterable password but might show other configuration details such as EAP type or server names.</p>
    </div>

    <h2 class="first-tool-heading">Tool 1: Sync Internals Password Extractor (for Networks Using a Passphrase)</h2>
    <p>This tool is designed to find passphrases for WiFi networks that use a pre-shared key (commonly WPA/WPA2-Personal). It works by examining data that ChromeOS may have synced with your Google account.</p>

    <h4>Technical Explanation: How This Tool Works</h4>
    <p>When you connect to a WiFi network on ChromeOS and are signed into your Google account with sync enabled, certain network configurations can be saved as part of your synced preferences. This often includes details for networks that use a simple passphrase for authentication.</p>
    <p>The <code>chrome://sync-internals</code> page provides a low-level view into this synchronized data. For WiFi networks, the Service Set Identifier (SSID, or WiFi name) is often stored in a hexadecimal (hex) encoded format, and the corresponding passphrase is typically stored in a base64 encoded format within a specific JSON (JavaScript Object Notation) data structure, usually under a key like <code>wifi_configuration</code>.</p>
    <p>This tool automates the process by:</p>
    <ol>
        <li>Guiding you to find the correct JSON data block within <code>chrome://sync-internals</code> (optionally by helping you convert your target SSID to its hex form for easier searching).</li>
        <li>Allowing you to paste this JSON data.</li>
        <li>Parsing the JSON to locate the SSID and the base64 encoded passphrase.</li>
        <li>Decoding the passphrase back into a human-readable format.</li>
    </ol>
    
    <h4>Step A: Prepare Your Search Term in Sync Internals (Optional but Recommended)</h4>
    <div class="extractor-tool-section">
        <label for="wifi_name_input">Enter SSID (WiFi Name) to get its Hex-Encoded version for searching:</label>
        <input type="text" id="wifi_name_input" placeholder="e.g., MyHomeWiFi (or leave blank to browse)">
        <button id="get_instructions_button">Get Hex-Encoded Search Term</button>
        <div class="tool-output-container" style="margin-top:10px;"> <pre id="sync_search_term_output" style="font-size:0.85em; min-height: 40px;">Enter an SSID above to see the recommended search key for Step B.</pre>
        </div>
    </div>

    <h4>Step B: Retrieve Data from <code>chrome://sync-internals</code></h4>
    <ol>
      <li>Open a new tab in your Chrome browser and navigate to <code>chrome://sync-internals</code>.</li>
      <li>Click on the "<strong>Search</strong>" tab located at the top of the page.</li>
      <li>In the search box on that page:
          <ul>
              <li>If you generated a hex-encoded search term in Step A, paste it here (e.g., <code>4D79486F6D6557694669&lt;||&gt;psk</code>) and press Enter.</li>
              <li>Otherwise, type <code>wifi_</code> and press Enter. You will then need to browse the results on the left for entries containing "<code>psk</code>" in their name that might correspond to your network.</li>
          </ul>
      </li>
      <li>Click the relevant entry from the list on the left side. This will display its detailed JSON data in the panel on the right.</li>
      <li>Carefully select and copy <strong>ALL</strong> of the JSON data shown on the right (it should start with <code>{</code> and end with <code>}</code>).</li>
    </ol>

    <h4>Step C: Extract Password with the Tool</h4>
    <div class="extractor-tool-section">
      <label for="sync_data_input">Paste Full JSON Data from <code>chrome://sync-internals</code> Here:</label>
      <textarea id="sync_data_input" placeholder="Paste the entire JSON object for the WiFi network here..."></textarea>
      <button id="extract_password_button_sync">Extract from Sync Data</button>
      <div class="tool-output-container">
        <h4>Output (Sync Internals):</h4>
        <pre id="sync_tool_output">Paste JSON data above and click extract.</pre>
      </div>
    </div>


    <h2>Tool 2: Network Policy Password Extractor (NPPE)</h2>
    <p>This tool attempts to find WiFi configurations by analyzing a network log file (<code>chrome-net-export-log.json</code>). It can be particularly useful if network settings are distributed via administrative policies on managed ChromeOS devices.</p>

    <h4>Technical Explanation: How This Tool Works</h4>
    <p>ChromeOS devices in managed environments (like schools or businesses) often receive their network configurations, including WiFi settings, through policies pushed by an administrator. These policies ensure devices connect to approved networks with specific settings.</p>
    <p>When network events occur or policies are updated, details of these configurations can sometimes be recorded in the comprehensive network logs generated by ChromeOS. The <code>chrome://net-export</code> utility allows users to capture these logs. Critically, selecting the "Include raw bytes" option during log generation is necessary, as policy data containing network configurations is often embedded as a base64 encoded string within the larger JSON log structure.</p>
    <p>The NPPE tool works by:</p>
    <ol>
        <li>Guiding you to generate a <code>chrome-net-export-log.json</code> file with the correct options (including the crucial step of reloading policies while logging is active to maximize the chance of capturing the configurations).</li>
        <li>Allowing you to upload this log file.</li>
        <li>Parsing the potentially large JSON log file to find specific event entries that contain policy data.</li>
        <li>Identifying and decoding any base64 encoded policy blobs.</li>
        <li>Parsing the decoded policy data (which itself is often JSON) to find a list called <code>NetworkConfigurations</code>.</li>
        <li>Extracting and displaying details for each configured WiFi network found, such as SSID, security type (e.g., WPA-PSK, WPA-EAP), and any available credentials (like a pre-shared key/passphrase, or EAP identity and settings).</li>
    </ol>
    <p>It's important to note that for EAP (Enterprise) networks, this tool will typically show configuration parameters (like EAP method, identity, server CA certificate info) rather than the user's actual password, as those are usually not stored or transmitted in a directly extractable way.</p>

    <h4>Step A: Generate and Save the <code>chrome-net-export-log.json</code> File</h4>
    <p>Follow these steps carefully on your ChromeOS device:</p>
    <ol>
        <li>Open a new tab and navigate to <code>chrome://net-export</code>.</li>
        <li>Under the "OPTIONS" section, ensure you select <strong>"Include raw bytes (includes cookies and credentials)"</strong>.
            <br><span class="warning">Warning:</span> This option captures sensitive data. Only proceed if you understand the implications and are handling the log file securely. Do NOT select "Include private information from all users" unless absolutely necessary and you are certain of the privacy implications.</li>
        <li>Click the <strong>"Start Logging to Disk"</strong> button. You will be prompted to save a file; it will typically be named <code>chrome-net-export-log.json</code>. Choose a location to save it.</li>
        <li><strong>Keep the <code>chrome://net-export</code> tab open and logging.</strong> Open another new tab and navigate to <code>chrome://policy</code>.</li>
        <li>On the <code>chrome://policy</code> page, click the <strong>"Reload policies"</strong> button. Wait a few seconds for the policies to refresh. This step is crucial for ensuring current network policies are captured in the log.</li>
        <li>Go back to the <code>chrome://net-export</code> tab and click the <strong>"Stop Logging"</strong> button.</li>
        <li>You now have the <code>chrome-net-export-log.json</code> file saved in the location you chose.</li>
    </ol>

    <h4>Step B: Upload and Analyze the Log</h4>
    <div class="extractor-tool-section nppe-tool">
        <label for="net_export_log_input">Upload your saved <code>chrome-net-export-log.json</code> file:</label>
        <input type="file" id="net_export_log_input" accept=".json">
        <div class="tool-output-container">
            <h4>Output (Network Policy Extractor):</h4>
            <table id="nppe_output_table">
              <thead>
                <tr>
                  <th>SSID</th>
                  <th>Credentials / Details</th>
                  <th>Security</th>
                  <th>HiddenSSID</th>
                </tr>
              </thead>
              <tbody>
                </tbody>
            </table>
            <pre id="nppe_log_output" style="font-size: 0.8em; margin-top:10px; max-height: 150px;">Upload a log file to see results.</pre>
        </div>
        <p style="font-size:0.85em; color:#aaa; margin-top:10px;">Note: For EAP networks, 'Credentials / Details' will show configuration parameters (like EAP method, identity) rather than a user-specific password.</p>
    </div>
    
    <h2>Troubleshooting (Both Tools)</h2>
    <ul>
      <li><strong>No Data Found:</strong> If a tool doesn't find anything, it means the WiFi information isn't stored or accessible via that specific method on your device configuration or ChromeOS version. The network might be configured in a way that isn't captured by these techniques (e.g., manual setup without sync, or policies not logged as expected).</li>
      <li><strong>Errors During Extraction:</strong> Ensure you copied the entire, correct JSON data for Tool 1, or uploaded the correct, unaltered log file for Tool 2. The structure of ChromeOS internal data or logs can change with updates, which might occasionally break these tools until they are adapted.</li>
      <li><strong>Tool 1 Specific - SSID Hex Encoding:</strong> If you manually search in `chrome://sync-internals` and your SSID has special characters, direct searching might be tricky. Using the "Get Hex-Encoded Search Term" feature is recommended.</li>
      <li><strong>Tool 2 Specific - Log File Size:</strong> <code>chrome-net-export-log.json</code> files can be very large. The tool processes it in your browser, which might be slow on less powerful devices. Ensure you stop logging reasonably quickly after reloading policies to keep the file size manageable.</li>
    </ul>

    <p class="credits">Sync Internals method original discovery by SimonTheCat#0651 in <a href="https://discord.gg/unblock" target="_blank" rel="noopener noreferrer">TitaniumNetwork</a>.<br>NPPE tool concept adapted from similar public research and tools.<br>This tool and guide are for educational purposes only. Please use responsibly.</p>

  </div> <script src="https://cdn.jsdelivr.net/npm/tsparticles@2.12.0/tsparticles.bundle.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // --- TS PARTICLES SCRIPT ---
      const isMobile = window.matchMedia("(max-width: 768px)").matches;
      const prefersReducedMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
      const particleSettings = {
        fpsLimit: 60, particles: { number: { value: prefersReducedMotion ? 0 : (isMobile ? 30 : 60), density: { enable: true, area: 800 } }, color: { value: "#666666" }, shape: { type: "circle" }, opacity: { value: 0.35 }, size: { value: 2.2, random: { enable: true, minimumValue: 0.8 } }, links: { enable: true, distance: 140, color: "#777777", opacity: 0.25, width: 1 }, move: { enable: !prefersReducedMotion, speed: 0.9, direction: "none", random: true, straight: false, outModes: { default: "out" } } }, interactivity: { events: { onHover: { enable: !prefersReducedMotion, mode: "repulse" }, onClick: { enable: !prefersReducedMotion, mode: "push" }, resize: true }, modes: { repulse: { distance: 70, duration: 0.4 }, push: { quantity: 2 } } }, detectRetina: true
      };
      function loadParticles() { if (typeof tsParticles !== "undefined") { tsParticles.load("tsparticles", particleSettings).then(container => { if (container && prefersReducedMotion) { if (container.particles && typeof container.particles.setCount === 'function') { container.particles.setCount(0); } if (container.stop) { container.stop(); } } }).catch(error => { console.error("Error loading TSPSarticles v2.12.0 on wifi.html:", error); }); } else { console.error("tsParticles library not found on wifi.html."); } }
      if ('requestIdleCallback' in window) { requestIdleCallback(loadParticles); } else { setTimeout(loadParticles, 100); }
      // --- END TS PARTICLES SCRIPT ---

      // --- SYNC INTERNALS WIFI EXTRACTOR SCRIPT ---
      const wifiNameInput_sync = document.getElementById("wifi_name_input");
      const getInstructionsButton_sync = document.getElementById("get_instructions_button");
      const syncDataInput_sync = document.getElementById("sync_data_input");
      const extractPasswordButton_sync = document.getElementById("extract_password_button_sync");
      const syncToolOutputPre = document.getElementById("sync_tool_output");
      const syncSearchTermOutputPre = document.getElementById("sync_search_term_output");


      if (getInstructionsButton_sync && wifiNameInput_sync && syncSearchTermOutputPre) {
        getInstructionsButton_sync.addEventListener("click", showSyncSearchTerm);
        wifiNameInput_sync.addEventListener("keydown", function(e) {
          if (e.key === "Enter") { e.preventDefault(); showSyncSearchTerm(); }
        });
      } else { console.error("Sync Internals Extractor elements (Step A) not found."); if(syncSearchTermOutputPre) syncSearchTermOutputPre.textContent = "Error: Tool UI (Step A) missing.";}
      
      if (extractPasswordButton_sync && syncDataInput_sync && syncToolOutputPre) {
        extractPasswordButton_sync.addEventListener("click", extractPasswordFromSyncData_sync);
      } else { console.error("Sync Internals Extractor elements (Step C) not found."); if(syncToolOutputPre) syncToolOutputPre.textContent = "Error: Tool UI (Step C) missing.";}

      function showSyncSearchTerm() {
        if (!wifiNameInput_sync || !syncSearchTermOutputPre) return;
        let ssid = wifiNameInput_sync.value.trim();
        if (ssid) {
          const hexSsid = hexEncode_sync(ssid);
          syncSearchTermOutputPre.innerHTML = `For SSID "<strong>${ssid}</strong>", try searching for this key in <code>chrome://sync-internals</code> (Search tab):<br><code style="font-size:0.9em; color:#61dafb;">${hexSsid}&lt;||&gt;psk</code>`;
        } else {
          syncSearchTermOutputPre.innerHTML = `If you leave the SSID field blank, you will need to manually browse <code>wifi_</code> entries containing "<code>psk</code>" in <code>chrome://sync-internals</code> (Search tab) to find your network.`;
        }
      }

      function extractPasswordFromSyncData_sync() {
        if (!syncDataInput_sync || !syncToolOutputPre) return;
        let jsonData = syncDataInput_sync.value.trim();
        syncToolOutputPre.className = ''; // Clear any previous error/success classes

        if (!jsonData) { syncToolOutputPre.innerHTML = `<span class="error">Error: Please paste the JSON data from chrome://sync-internals.</span>`; return; }
        
        // Basic JSON validation (more can be added)
        if (!jsonData.startsWith("{") || !jsonData.endsWith("}")) { 
            syncToolOutputPre.innerHTML = `<span class="error">Error: Pasted data does not appear to be a valid JSON object. Please ensure you copied the entire object.</span>`; 
            return; 
        }
        
        try {
          const json = JSON.parse(jsonData);
          // Updated to check more specific path based on typical sync_internals structure
          if (json.SPECIFICS && json.SPECIFICS.wifi_configuration && json.SPECIFICS.wifi_configuration.hex_ssid && json.SPECIFICS.wifi_configuration.passphrase) {
            let hexSsidFromData = json.SPECIFICS.wifi_configuration.hex_ssid;
            let decodedSsid = hexDecode_sync(hexSsidFromData); // hex_ssid is already hex
            const passphrase = atob(json.SPECIFICS.wifi_configuration.passphrase); // Passphrase is base64
            
            syncToolOutputPre.innerHTML = `<span class="success">Data successfully extracted:</span>\n\n<strong>SSID (from Hex):</strong> ${decodedSsid}\n<strong>Password:</strong> ${passphrase}`;
          } else if (json.NON_UNIQUE_NAME && json.SPECIFICS && json.SPECIFICS.wifi_configuration && json.SPECIFICS.wifi_configuration.passphrase) {
            // Fallback for older potential structures if NON_UNIQUE_NAME was used for hex SSID
            let ssidPart = json.NON_UNIQUE_NAME.split("<")[0];
             // NON_UNIQUE_NAME might already be hex or plain text. If it's hex, decode it.
            let decodedSsid = ssidPart;
            if (/^[0-9A-F]+$/i.test(ssidPart) && ssidPart.length % 2 === 0) { // Check if it looks like hex
                try { decodedSsid = hexDecode_sync(ssidPart); } catch(e) { /* keep original if decode fails */ }
            }
            const passphrase = atob(json.SPECIFICS.wifi_configuration.passphrase);
            syncToolOutputPre.innerHTML = `<span class="success">Data successfully extracted (using NON_UNIQUE_NAME):</span>\n\n<strong>SSID (from NON_UNIQUE_NAME):</strong> ${decodedSsid}\n<strong>Password:</strong> ${passphrase}`;
          }
          else { 
            throw new Error("The pasted JSON does not contain the expected WiFi configuration fields (SPECIFICS.wifi_configuration.hex_ssid and .passphrase). Please ensure you copied the correct JSON object for a WiFi network node."); 
          }
        } catch (e) { 
          console.error("Sync Internals Extractor Error:", e); 
          syncToolOutputPre.innerHTML = `<span class="error">Error processing JSON:</span> ${e.message || e.toString().toLowerCase()}. Check console for more details.`; 
        }
      }

      function hexEncode_sync(text) { return text.split("").map((char) => char.charCodeAt(0).toString(16).padStart(2, "0")).join("").toUpperCase(); }
      function hexDecode_sync(hexString) { 
        if (!hexString || typeof hexString !== 'string' || !/^[0-9A-Fa-f]+$/i.test(hexString.replace(/[^0-9A-Fa-f]/g, '')) || hexString.length % 2 !== 0) { 
            // console.warn("Invalid hex string for decoding:", hexString);
            return hexString; // Return original if not valid hex
        } 
        try { 
            return hexString.match(/.{1,2}/g).map((byte) => String.fromCharCode(parseInt(byte, 16))).join(""); 
        } catch (e) { 
            // console.warn("Could not hex decode:", hexString, e); 
            return hexString; // Return original on error
        } 
      }
      // --- END SYNC INTERNALS WIFI EXTRACTOR SCRIPT ---

      // --- NPPE SCRIPT ---
      const nppeFileInput = document.getElementById("net_export_log_input");
      const nppeOutputTableBody = document.querySelector("#nppe_output_table tbody");
      const nppeLogOutput = document.getElementById("nppe_log_output");

      function nppeLog(txt, isError = false, isSuccess = false) {
          if (nppeLogOutput) {
              const entry = document.createElement("div");
              entry.textContent = txt;
              if(isError) entry.className = 'error';
              if(isSuccess) entry.className = 'success';
              nppeLogOutput.appendChild(entry);
              nppeLogOutput.scrollTop = nppeLogOutput.scrollHeight; 
          }
      }

      function extractNPPE(event) {
        if (!nppeOutputTableBody || !nppeLogOutput) return;
        nppeOutputTableBody.innerHTML = ''; 
        nppeLogOutput.innerHTML = ''; // Clear previous log entries
        nppeLog("Processing log file...", false);

        let file = event.target.files[0];
        if (!file) { nppeLog("No file selected.", true); return; }
        if (!file.name.endsWith(".json")) { nppeLog("Invalid file type. Please upload a .json file generated by chrome://net-export.", true); return; }
        
        let reader = new FileReader();
        reader.readAsText(file);
        reader.onload = (e) => {
          let netlogContent = e.target.result;
          let policyNetsLines = [];
          const keywords = ["ya0NvbmZpZ3VyYXRpb2", "vcmtDb25maWd1cmF0aW", "rQ29uZmlndXJhdGlvbn", "Db25maWd1cmF0aW9ucw"]; // Base64 snippets of "NetworkConfigurations" or similar
          
          // Split by lines, but also handle cases where the entire log is one massive line (less common for net-export)
          const lines = netlogContent.split('\n');
          for (const line of lines) {
            if (keywords.some(keyword => line.includes(keyword))) {
              policyNetsLines.push(line);
            }
          }

          if (policyNetsLines.length === 0) {
            nppeLog("No lines containing typical NetworkConfiguration policy keywords found in the log. Ensure 'Include raw bytes' was enabled and policies were reloaded during logging.", true);
            return;
          }
          nppeLog(`Found ${policyNetsLines.length} potential lines containing policy data. Attempting to parse...`);

          let networksFound = 0;
          policyNetsLines.forEach((line, lineIndex) => {
            try {
              const lineJson = JSON.parse(line); // Each line from net-export log is typically a JSON object
              if (lineJson.params && lineJson.params.bytes) {
                let decodedBytes = "";
                try {
                    decodedBytes = atob(lineJson.params.bytes);
                } catch (decodeError) {
                    nppeLog(`Line ${lineIndex+1}: Error decoding base64 bytes: ${decodeError.message}. Skipping.`, true);
                    return; // continue to next line
                }

                // The decodedBytes might be a complex string, try to find JSON within it
                // Looking for "NetworkConfigurations": [...]
                const networkConfigsMatch = decodedBytes.match(/"NetworkConfigurations"\s*:\s*(\[.*?\])/s);
                if (networkConfigsMatch && networkConfigsMatch[1]) {
                  let networkConfigurationsArray;
                  try {
                    networkConfigurationsArray = JSON.parse(networkConfigsMatch[1]);
                  } catch (jsonErr) {
                    nppeLog(`Line ${lineIndex+1}: Error parsing NetworkConfigurations JSON: ${jsonErr.message}. Skipping.`, true);
                    return; // continue to next line
                  }

                  if (networkConfigurationsArray.length > 0) {
                    nppeLog(`Line ${lineIndex+1}: Found and parsed ${networkConfigurationsArray.length} network(s) within this entry.`);
                  }

                  for (const wifiConfig of networkConfigurationsArray) {
                    if (!wifiConfig || !wifiConfig.WiFi || !wifiConfig.WiFi.SSID) {
                      continue; // Skip invalid/incomplete entries silently or add a log
                    }
                    networksFound++;
                    let tr = document.createElement("tr");
                    
                    let ssidTd = document.createElement("td");
                    ssidTd.textContent = wifiConfig.WiFi.SSID;
                    
                    let securityTd = document.createElement("td");
                    securityTd.textContent = wifiConfig.WiFi.Security || "Unknown";
                    
                    let credsTd = document.createElement("td");
                    if (wifiConfig.WiFi.Passphrase) {
                      credsTd.textContent = wifiConfig.WiFi.Passphrase;
                    } else if (wifiConfig.WiFi.EAP) {
                      let eapDetails = `Type: ${wifiConfig.WiFi.EAP.Outer || 'N/A'}`;
                      if(wifiConfig.WiFi.EAP.Identity) eapDetails += `\nIdentity: ${wifiConfig.WiFi.EAP.Identity}`;
                      // Add more EAP fields if needed, e.g., AnonymousIdentity, Inner, ServerCARefs, etc.
                      credsTd.innerText = eapDetails; 
                    } else {
                      credsTd.textContent = "NOT FOUND/N.A.";
                    }
                    
                    let hiddenSsidTd = document.createElement("td");
                    hiddenSsidTd.textContent = wifiConfig.WiFi.HiddenSSID ? "Yes" : "No";
                    
                    tr.appendChild(ssidTd);
                    tr.appendChild(credsTd);
                    tr.appendChild(securityTd);
                    tr.appendChild(hiddenSsidTd);
                    nppeOutputTableBody.appendChild(tr);
                  }
                }
              }
            } catch (err) {
              // This catches errors from parsing the individual line `lineJson = JSON.parse(line);`
              // nppeLog(`Line ${lineIndex+1}: Not a valid JSON line or unexpected structure. Skipping.`, true);
              // console.warn("Skipping non-JSON line or line with unexpected structure in net-export log:", line);
            }
          });
          
          if (networksFound === 0) {
             nppeLog("Processing complete. No extractable WiFi configurations found in the provided log matching expected policy structures.", true);
          } else {
             nppeLog(`Extraction complete. Displayed ${networksFound} network configuration(s).`, false, true);
          }
        };
        reader.onerror = () => {
            nppeLog("Error reading the uploaded file.", true);
        };
      }

      if (nppeFileInput) {
        nppeFileInput.addEventListener("change", extractNPPE);
      } else {
        console.error("NPPE file input element not found.");
        if(nppeLogOutput) nppeLog("Critical Error: NPPE file input UI element is missing from the page.", true);
      }
      // --- END NPPE SCRIPT ---

      // --- Navigation JavaScript is now in external files ---
    });
  </script>

  <script src="nav-data.js"></script>
  <script src="navigation.js"></script>

</body>
</html>